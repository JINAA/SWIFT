생각하면서 코딩하기!!!

# f

- Factorial : 참고 - https://ko.khanacademy.org/computing/computer-science/algorithms/recursive-algorithms/a/the-factorial-function
  1부터 n까지의 정수를 곱하는 연산
  5! = 1*2*3*4*5
  사물의 순서를 정하거나 조합할 때 얼마나 많은 방법이 있는지 구할 때 유용한 함
- 팩토리패턴: 프로토콜을 채택하는 구조체들을 이용해서 값을 미리 예측할 수 있도록 해주는 것 ?!

# s

- static : 인스턴스를 생성하지 않아도 내부 메서드 사용가능

  단순한 구조의 메소드의 경우 static을 사용하면 구조체의 인스턴스를 계속 생성하면서 불필요한 구조체 init과 호출을 줄일 수 있다.

- 사이드 이펙트

  : 부작용

  : 사전적인 정의와는 다르게 프로그래밍에서는 꼭 부정적인 말은 아니다. 사이드 이펙트는 요구되어지는 이펙트 이외의 다른 이펙트가 발생하는 현상을 말하는 것으로, 꼭 나쁜 결과만을 도출한다고는 할 수 없다. 그렇다고 좋은 결과를 내는 좋은 사이드 이펙트는 아니다.

  

  + 빈 구문이 아니라면 반드시 하나의 사이드 이펙트를 가져야 한다(빈 구문이 아닌데 사이드 이펙트가 없는 구문은 일반적으로 프로그래밍 에러를 가리킨다.)

  - 실행중에 어떤 객체를 접근해서 변화가 일어나느 행위

  - 일부 변수가 표현 값의 부산물로 바뀌는 것

  - 수정하는 연산자들을 사이드 이펙트를 가졌다고 한다.

  - 값을 내는 것 이외에 어떤 상태나 관찰 가능한 상호 작용이 발생하는 것

# m

- Mutating

: 구조체와 열겨형은 값 타입이다. 기본적으로 값 타입의 속성은 인스턴스 메소드 안에서 수정할 수가 없다. 

그러나 특정 메소드 안에 속성을 수정할 필요가 있다면, 메소드에 변경 동작을 선택할 수 있다. 그러면 메소드는 속성을 변경할 수 있으며, 모든 변경은 메소드가 끝날 때 기존 구조체가 쓰여진 후에 적용이 된다. 메소드는 암시적인 self속성에 새로운 인스턴스를 완전히 할당할 수 있으며, 새로운 인스턴스는 메소드가 끝난 뒤에 교체된다.

```swift
struct vendingMachine {
  private var inventory: [String:Int]
    mutating func fill() {
        for drinks in beverage {
            let name = drinks.beverageName
            inventory[name] = 1
        }
    }
}
```

# g

- Getter vs function

: function을 사용하면 외부에서 해당 변수를 이용할 때 매번 새롭게 생성해야 하는 소스의 반복이 생긴다. 혹은  또 다른 곳에서 값을 사용할 때 소스의 반복으로 오류가 생길 가능성이 생긴다. (값이 서로 동일하지 않을 수 있다.)

반면 getter를 사용하면 어디에서 사용하던지 동일한 결과를 얻을 수 있게 된다.

- GRASP

  [https://medium.com/@codesquad_yoda/%EC%8A%A4%EC%9C%84%ED%94%84%ED%8A%B8%EC%99%80-grasp-%ED%8C%A8%ED%84%B4-d5e37a1bb5dc](https://medium.com/@codesquad_yoda/스위프트와-grasp-패턴-d5e37a1bb5dc)

# l

- localizer

- initalization

  https://github.com/conyconydev/conyconydev.github.io/blob/master/_posts/ios/2019-05-01-Initialization.md
  
- Indirection(간접참조) : 모든 변수 상수들은 간접참조다

  즉 어떠한 코드(변수,클래스,메소드 등)의 이름을 정해서 연결 시켜주는 것을 말함

# r

- regularExpression

  Tokenizer, parser, lexers의 정의

  - Tokenizer : 값만 찾아내는과정
  - Lexer : 그 값이 누구인지 알려줌
  - Parser : 입력 token에 내재된 자료 구조를 빌드하고 문법을 검사, 컴파일러의 일부로 컴ㄹ파일러나 인터프리터에서 원시 프로그램을 읽어 들여 그 문장의 구조를 알아내는 파싱(parsing: 구문분석)을 행하는 프로그램

  

- Reference counting

# u

- UX / UI : 참고 http://media.fastcampus.co.kr/knowledge/about-uxuidesign/
  UX : 사용자의 겸험을 토대로 어떤식으로 설계를 할지를 디자인 하는 것
  UI : 사용자가 실제로 보게 될 디자인
  즉, UX는 어떤식으로 설계를 할지 스케치 하는 것이라면 UI는 스케치를 토대로 색을 입히고 어떤 모양으로 만들지에 대한 시각적인 디자인을 말한다.
  
- UML : [http://www.nextree.co.kr/p6753/](http://www.nextree.co.kr/p6753/)

# t

- 단위테스트와 통합테스트

  단위테스트: 메소드 혹은 서비스를 **단위별로** 개발자가 계발 후 정상 동작확인

  통합테스트 : 전체 프로그램을 사용하는 시나리오 대로 케이스별 테스트

  ( = 단위테스트와 달리 메소드들 끼리 관계를 가지고 있는 상태에서 테스트)

# c

- Computed property : 

  Getter? Setter?

# d

- DTO



